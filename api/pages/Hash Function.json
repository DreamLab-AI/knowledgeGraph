{
  "title": "Hash Function",
  "content": "- ### OntologyBlock\n  id:: hash-function-ontology\n  collapsed:: true\n\n  - **Identification**\n\n    - domain-prefix:: BC\n\n    - sequence-number:: 0027\n\n    - filename-history:: [\"BC-0027-hash-function.md\"]\n    - public-access:: true\n    - ontology:: true\n    - term-id:: BC-0027\n    - preferred-term:: Hash Function\n    - source-domain:: blockchain\n    - status:: complete\n    - version:: 1.0.0\n    - last-updated:: 2025-10-28\n\n  - **Definition**\n    - definition:: One-way data transformation within blockchain systems, providing essential functionality for distributed ledger technology operations and properties.\n    - maturity:: mature\n    - source:: [[ISO/IEC 23257:2021]], [[IEEE 2418.1]], [[NIST NISTIR]]\n    - authority-score:: 1.0\n\n  - **Semantic Classification**\n    - owl:class:: bc:HashFunction\n    - owl:physicality:: VirtualEntity\n    - owl:role:: Object\n    - owl:inferred-class:: bc:VirtualObject\n    - belongsToDomain:: [[CryptographicDomain]]\n    - implementedInLayer:: [[SecurityLayer]]\n\n  - #### Relationships\n    id:: hash-function-relationships\n    - is-subclass-of:: [[Blockchain Entity]], [[CryptographicPrimitive]]\n\n  - #### OWL Axioms\n    id:: hash-function-owl-axioms\n    collapsed:: true\n    - ```clojure\n      Prefix(:=<http://metaverse-ontology.org/blockchain#>)\n      Prefix(owl:=<http://www.w3.org/2002/07/owl#>)\n      Prefix(rdf:=<http://www.w3.org/1999/02/22-rdf-syntax-ns#>)\n      Prefix(xml:=<http://www.w3.org/XML/1998/namespace>)\n      Prefix(xsd:=<http://www.w3.org/2001/XMLSchema#>)\n      Prefix(rdfs:=<http://www.w3.org/2000/01/rdf-schema#>)\n      Prefix(dct:=<http://purl.org/dc/terms/>)\n\n      Ontology(<http://metaverse-ontology.org/blockchain/BC-0027>\n        Import(<http://metaverse-ontology.org/blockchain/core>)\n\n        ## Class Declaration\n        Declaration(Class(:HashFunction))\n\n        ## Subclass Relationships\n        SubClassOf(:HashFunction :CryptographicPrimitive)\n        SubClassOf(:HashFunction :BlockchainEntity)\n\n        ## Essential Properties\n        SubClassOf(:HashFunction\n          (ObjectSomeValuesFrom :partOf :Blockchain))\n\n        SubClassOf(:HashFunction\n          (ObjectSomeValuesFrom :hasProperty :Property))\n\n        ## Data Properties\n        DataPropertyAssertion(:hasIdentifier :HashFunction \"BC-0027\"^^xsd:string)\n        DataPropertyAssertion(:hasAuthorityScore :HashFunction \"1.0\"^^xsd:decimal)\n        DataPropertyAssertion(:isFoundational :HashFunction \"true\"^^xsd:boolean)\n\n        ## Object Properties\n        ObjectPropertyAssertion(:enablesFeature :HashFunction :BlockchainFeature)\n        ObjectPropertyAssertion(:relatesTo :HashFunction :RelatedConcept)\n\n        ## Annotations\n        AnnotationAssertion(rdfs:label :HashFunction \"Hash Function\"@en)\n        AnnotationAssertion(rdfs:comment :HashFunction\n          \"One-way data transformation\"@en)\n        AnnotationAssertion(dct:description :HashFunction\n          \"Foundational blockchain concept with formal ontological definition\"@en)\n        AnnotationAssertion(:termID :HashFunction \"BC-0027\")\n        AnnotationAssertion(:priority :HashFunction \"1\"^^xsd:integer)\n        AnnotationAssertion(:category :HashFunction \"cryptographic-foundations\"@en)\n      )\n      ```\n\n- ## Core Definition and Fundamentals\n  id:: hash-function-fundamentals\n\n  - **Hash Function Overview**\n    - A [[cryptographic hash function]] is a mathematical algorithm that transforms input data of arbitrary size into a fixed-length output string (hash digest or hash value)\n    - Serves as a fundamental [[cryptographic primitive]] in [[blockchain]] systems, [[digital signatures]], [[data integrity]] verification, and [[consensus mechanisms]]\n    - Essential for [[Bitcoin]], [[Ethereum]], and virtually all [[distributed ledger]] technologies\n    - Functions as a one-way transformation: computationally infeasible to reverse or find the original input from the hash output\n    - Provides deterministic output: identical inputs always produce identical hash values\n\n  - **Mathematical Properties**\n    - **Determinism**: Same input always yields same output hash\n    - **Fixed Output Size**: Regardless of input size, output is constant length (e.g., SHA-256 produces 256-bit output)\n    - **Computational Efficiency**: Fast to compute hash from any input\n    - **Pre-image Resistance**: Given hash value h, computationally infeasible to find input m where hash(m) = h\n    - **Second Pre-image Resistance**: Given input m1, infeasible to find different input m2 where hash(m1) = hash(m2)\n    - **Collision Resistance**: Computationally infeasible to find any two different inputs m1, m2 where hash(m1) = hash(m2)\n    - **Avalanche Effect**: Small change in input produces dramatically different output (typically 50% bit flip)\n    - **Uniformity**: Output distribution appears random across entire output space\n\n- ## Bitcoin-Specific Hash Function Implementation\n  id:: hash-function-bitcoin\n\n  - **SHA-256 in Bitcoin Mining**\n    - [[Bitcoin]] uses [[SHA-256]] (Secure Hash Algorithm 256-bit) as its primary [[proof-of-work]] hash function\n    - [[Mining]] involves computing double SHA-256: SHA-256(SHA-256(block_header))\n    - [[Miners]] iterate through [[nonce]] values seeking hash output below target [[difficulty]] threshold\n    - Target difficulty adjusted every 2,016 blocks (~2 weeks) to maintain 10-minute average block time\n    - Current [[hash rate]] (2025): Exceeds 500 EH/s (exahashes per second) globally\n    - **Bitcoin Block Header Hashing**:\n      - Version (4 bytes) + Previous Block Hash (32 bytes) + [[Merkle Root]] (32 bytes)\n      - Timestamp (4 bytes) + Difficulty Target (4 bytes) + Nonce (4 bytes)\n      - Total 80-byte header hashed repeatedly during mining\n    - Double hashing provides additional security margin against potential SHA-256 vulnerabilities\n    - [[ASIC]] miners optimized specifically for SHA-256 computation dominate mining landscape\n\n  - **Bitcoin Address Generation**\n    - Bitcoin addresses use combination of SHA-256 and [[RIPEMD-160]]\n    - Public key → SHA-256 → RIPEMD-160 → Base58Check encoding\n    - RIPEMD-160 reduces 256-bit SHA-256 output to 160-bit hash\n    - Provides shorter addresses while maintaining security (2^160 address space)\n    - [[P2PKH]] (Pay-to-Public-Key-Hash) addresses: 1-prefix legacy addresses\n    - [[P2SH]] (Pay-to-Script-Hash): 3-prefix addresses for [[multisig]] and scripts\n    - [[Bech32]] addresses ([[SegWit]]): Use same hash but different encoding (bc1-prefix)\n\n  - **Merkle Tree Construction in Bitcoin**\n    - [[Merkle tree]] enables efficient transaction verification in [[blocks]]\n    - Each transaction hashed with SHA-256, pairs combined and hashed recursively\n    - Creates binary tree structure with single [[Merkle root]] in block header\n    - Enables [[SPV]] (Simplified Payment Verification) clients to verify transactions without full blockchain\n    - [[Merkle proof]] requires only log2(n) hashes to verify transaction in block with n transactions\n    - Bitcoin blocks can contain 2,000-4,000 transactions, Merkle proof needs only 12-13 hashes\n    - Merkle root commits to all transactions, any change invalidates entire tree\n\n- ## Common Hash Functions in Blockchain\n  id:: hash-function-algorithms\n\n  - **SHA-256 (Secure Hash Algorithm 256-bit)**\n    - Designed by [[NSA]], published by [[NIST]] in 2001 as part of SHA-2 family\n    - Produces 256-bit (32-byte) hash output\n    - Used in [[Bitcoin]], [[Bitcoin Cash]], [[Bitcoin SV]], many [[proof-of-work]] chains\n    - Operates on 512-bit message blocks through 64 rounds of processing\n    - Security based on computational complexity: ~2^256 operations for brute force\n    - No practical attacks found against SHA-256 as of 2025\n    - Quantum computers could theoretically reduce security to 2^128 via [[Grover's algorithm]]\n\n  - **SHA-3 (Keccak)**\n    - Won NIST hash function competition in 2012, standardized 2015\n    - Based on [[sponge construction]] rather than [[Merkle-Damgård construction]]\n    - Variable output length: SHA3-224, SHA3-256, SHA3-384, SHA3-512\n    - Different internal structure from SHA-2, provides algorithmic diversity\n    - Used in some newer blockchain projects as alternative to SHA-256\n    - More resistant to [[length extension attacks]] than SHA-2\n\n  - **Keccak-256 (Ethereum)**\n    - [[Ethereum]] uses Keccak-256, variant of SHA-3 with different padding\n    - All [[Ethereum addresses]] derived from Keccak-256 hash of public key\n    - [[Smart contracts]], [[transaction hashes]], [[state roots]] all use Keccak-256\n    - Different from standardized SHA3-256 due to padding differences\n    - Produces 256-bit output like SHA-256 but different algorithm\n    - Used in [[EVM]] (Ethereum Virtual Machine) for address computation\n\n  - **RIPEMD-160**\n    - RACE Integrity Primitives Evaluation Message Digest, 160-bit output\n    - Developed in Europe as alternative to NSA-designed algorithms\n    - Used in Bitcoin address generation (after SHA-256)\n    - 160-bit output provides 2^160 possible hash values\n    - Shorter than SHA-256 but sufficient security for address space\n    - Less widely analyzed than SHA-2 family but no practical breaks\n\n  - **Blake2**\n    - Modern hash function faster than SHA-2, at least as secure\n    - Used in [[Zcash]], [[Sia]], [[Decred]], other cryptocurrencies\n    - Blake2b produces up to 512-bit output, Blake2s up to 256-bit\n    - Optimized for 64-bit platforms (Blake2b) and 32-bit platforms (Blake2s)\n    - Supports keyed hashing (MAC functionality) and tree hashing\n    - 2-10x faster than SHA-2 on modern processors\n\n  - **Scrypt and Memory-Hard Functions**\n    - [[Scrypt]] designed as memory-hard hash function for [[Litecoin]]\n    - Requires significant memory allocation, resistant to [[ASIC]] optimization\n    - Uses password-based key derivation function (PBKDF) internally\n    - Configurable memory requirements and computation time\n    - [[Dogecoin]] and other \"ASIC-resistant\" coins use Scrypt variants\n\n- ## Hash-Based Data Structures\n  id:: hash-function-data-structures\n\n  - **Merkle Trees**\n    - Binary tree where each leaf node is hash of data block\n    - Each non-leaf node is hash of its child nodes\n    - Single root hash (Merkle root) represents entire dataset\n    - Enables efficient [[data integrity]] verification with logarithmic proof size\n    - Used in Bitcoin blocks, [[IPFS]], [[Git]], [[Apache Cassandra]]\n    - **Merkle Proof Verification**:\n      - To prove transaction inclusion, provide sibling hashes from leaf to root\n      - Verifier recomputes path and compares with known Merkle root\n      - Proof size O(log n) for n transactions, verification O(log n)\n    - [[Merkle mountain range]] variant used in [[Grin]], [[Beam]] for efficient append operations\n\n  - **Merkle Patricia Trees**\n    - Combines [[Patricia trie]] (radix tree) with Merkle tree properties\n    - Used extensively in [[Ethereum]] for state storage\n    - Three types in Ethereum: state trie, storage trie, transaction trie\n    - Enables efficient key-value lookups with cryptographic verification\n    - Each node's hash depends on all descendant nodes\n    - Supports efficient updates: only path to changed leaf needs rehashing\n    - More complex than simple Merkle tree but enables stateful blockchain\n\n  - **Hash Tables and Hash Maps**\n    - Use hash functions to map keys to array positions\n    - Not cryptographic use, but demonstrates hash function versatility\n    - Collision handling via chaining or open addressing\n    - Expected O(1) lookup, insert, delete operations\n    - Critical data structure in blockchain node implementations\n\n  - **Bloom Filters**\n    - Probabilistic data structure using multiple hash functions\n    - Tests set membership: may have false positives, never false negatives\n    - Used in [[Bitcoin SPV]] clients to filter relevant transactions\n    - Space-efficient: represents set with much less memory than storing all elements\n    - Multiple hash functions (typically 3-10) map element to bit array\n    - [[BIP37]] defines Bloom filter usage in Bitcoin light clients\n\n- ## Mining and Proof-of-Work Applications\n  id:: hash-function-mining\n\n  - **Hash-Based Consensus Mechanisms**\n    - [[Proof-of-Work]] requires finding hash below target difficulty\n    - [[Difficulty adjustment]] maintains consistent block production rate\n    - [[Nakamoto consensus]] uses longest chain rule based on accumulated hash work\n    - [[Hashcash]] (Adam Back, 1997) pioneered proof-of-work concept using hash functions\n    - Mining difficulty represented as target hash: valid block hash must be numerically less than target\n\n  - **Nonce Iteration and Mining Process**\n    - [[Nonce]] (number used once) incremented by miner seeking valid hash\n    - Bitcoin's 32-bit nonce provides 4.3 billion attempts per block header configuration\n    - Modern [[ASIC]] miners exhaust nonce space in milliseconds\n    - Miners also iterate [[timestamp]] and [[extraNonce]] in coinbase transaction for additional search space\n    - **Mining Hardware Evolution**:\n      - CPU mining (2009-2010): ~1-10 MH/s\n      - GPU mining (2010-2013): ~100-1000 MH/s\n      - FPGA mining (2011-2013): ~100-25,000 MH/s\n      - ASIC mining (2013-present): GH/s to TH/s per device\n      - Modern ASICs (2025): Individual chips exceed 300 TH/s\n\n  - **Hash Rate and Network Security**\n    - [[Hash rate]] measures mining computational power (hashes per second)\n    - Higher hash rate increases [[51% attack]] cost, improving security\n    - Bitcoin hash rate growth: 10 H/s (2009) → 500+ EH/s (2025)\n    - **Hash Rate Units**:\n      - KH/s (kilohash): 1,000 hashes/second\n      - MH/s (megahash): 1,000,000 hashes/second\n      - GH/s (gigahash): 1 billion hashes/second\n      - TH/s (terahash): 1 trillion hashes/second\n      - PH/s (petahash): 1 quadrillion hashes/second\n      - EH/s (exahash): 1 quintillion hashes/second\n    - [[Mining pools]] aggregate hash rate for consistent reward distribution\n\n  - **Alternative Proof-of-Work Algorithms**\n    - [[Ethash]] ([[Ethereum]] pre-merge): Memory-hard algorithm using [[DAG]] (Directed Acyclic Graph)\n    - [[Equihash]] ([[Zcash]]): Based on [[birthday problem]], ASIC-resistant design\n    - [[RandomX]] ([[Monero]]): CPU-optimized, uses random code execution\n    - [[ProgPoW]]: Proposed Ethereum algorithm maximizing GPU efficiency\n    - Each algorithm attempts different hardware optimization tradeoffs\n\n- ## Digital Signatures and Cryptographic Applications\n  id:: hash-function-signatures\n\n  - **Hash Functions in Digital Signatures**\n    - [[Digital signatures]] sign hash of message, not message itself\n    - Enables signing arbitrarily large messages with fixed-size signature\n    - **Signature Process**:\n      - Message m hashed: h = hash(m)\n      - Private key signs hash: signature = sign(private_key, h)\n      - Verifier computes hash(m) and verifies signature with public key\n    - Hash provides integrity: changing message changes hash, invalidates signature\n    - All major signature schemes ([[ECDSA]], [[Schnorr]], [[EdDSA]]) hash before signing\n\n  - **Bitcoin Transaction Signing**\n    - [[ECDSA]] signatures in Bitcoin sign double-SHA-256 hash of transaction\n    - Different [[sighash types]] specify which transaction parts included in hash\n    - SIGHASH_ALL: Signs all inputs and outputs\n    - SIGHASH_NONE: Signs inputs only, allows output modification\n    - SIGHASH_SINGLE: Signs corresponding output only\n    - SIGHASH_ANYONECANPAY: Signs single input, allows adding more inputs\n    - [[Schnorr signatures]] ([[Taproot]], BIP340) also hash transaction data\n\n  - **Message Authentication Codes (MAC)**\n    - [[HMAC]] (Hash-based Message Authentication Code) provides keyed authentication\n    - HMAC(key, message) = hash((key ⊕ opad) || hash((key ⊕ ipad) || message))\n    - Used in [[payment channels]], [[Lightning Network]] commitment transactions\n    - Provides both authentication and integrity with shared secret key\n    - Resistant to [[length extension attacks]] affecting plain hash functions\n\n- ## Content Addressing and Distributed Systems\n  id:: hash-function-content-addressing\n\n  - **Content-Addressable Storage**\n    - [[Content addressing]] uses hash of data as its identifier/address\n    - Same content always produces same address (deduplication)\n    - Different from location addressing (URLs, IP addresses)\n    - Enables verifiable retrieval: hash of retrieved data must match address\n    - Fundamental to [[IPFS]] (InterPlanetary File System), [[BitTorrent]], [[Git]]\n\n  - **IPFS and Hash-Based Storage**\n    - [[IPFS]] uses [[multihash]] format supporting multiple hash algorithms\n    - Default: SHA-256 for files, creates [[CID]] (Content Identifier)\n    - Files split into blocks (default 256KB), each block hashed\n    - Directory structure represented as [[Merkle DAG]] (Directed Acyclic Graph)\n    - Enables efficient deduplication: identical blocks stored once\n    - [[IPLD]] (InterPlanetary Linked Data) extends concept across data structures\n\n  - **Arweave and Permanent Storage**\n    - [[Arweave]] uses SHA-256 for content addressing\n    - [[Permaweb]] applications reference data by hash\n    - [[SPoRA]] (Succinct Proofs of Random Access) consensus uses hash-based challenges\n    - Miners must prove access to random historical data via hash verification\n\n  - **Git and Version Control**\n    - [[Git]] uses SHA-1 (transitioning to SHA-256) for all object addresses\n    - Commits, trees, blobs all addressed by hash of their content\n    - Entire repository history verified by hash chain\n    - Changing any historical data invalidates all subsequent commit hashes\n    - [[Merkle tree]] structure enables efficient delta synchronization\n\n- ## Security Considerations and Attack Vectors\n  id:: hash-function-security\n\n  - **Collision Attacks**\n    - [[Collision attack]] finds two inputs producing same hash output\n    - Birthday paradox: ~2^(n/2) attempts to find collision in n-bit hash\n    - SHA-1 collision found in 2017 (SHAttered attack), cost ~$100,000\n    - No practical collision found for SHA-256 as of 2025\n    - Bitcoin's double SHA-256 provides additional collision resistance\n    - Collision resistance critical for [[digital signature security]]\n\n  - **Pre-image and Second Pre-image Attacks**\n    - [[Pre-image attack]]: Given hash h, find any input m where hash(m) = h\n    - [[Second pre-image attack]]: Given m1, find m2 where hash(m1) = hash(m2)\n    - Pre-image resistance essential for [[proof-of-work]] security\n    - If pre-images easily found, miners could bypass difficulty requirement\n    - Second pre-image attacks could enable [[transaction malleability]]\n\n  - **Length Extension Attacks**\n    - Exploit [[Merkle-Damgård construction]] used in SHA-1, SHA-2\n    - Given hash(message), attacker can compute hash(message || extension)\n    - Mitigated by HMAC construction or using SHA-3\n    - Bitcoin's double SHA-256 prevents length extension attacks\n    - Reason Ethereum chose Keccak over SHA-256 for some applications\n\n  - **Quantum Computing Threats**\n    - [[Grover's algorithm]] provides quadratic speedup for hash pre-image search\n    - Reduces 256-bit hash security to ~128 bits quantum security\n    - SHA-256 still considered quantum-resistant (128-bit security sufficient)\n    - [[Shor's algorithm]] breaks [[public key cryptography]] but not hash functions\n    - Post-quantum signatures needed, but hash functions remain secure\n\n  - **Hash Rate Attacks**\n    - [[51% attack]]: Attacker with >50% hash rate can rewrite blockchain\n    - [[Selfish mining]]: Strategic block withholding for profit\n    - [[Time-warp attack]]: Manipulating timestamps to reduce difficulty\n    - Mitigated by high hash rate, [[checkpoints]], [[finality gadgets]]\n    - Smaller cryptocurrencies vulnerable to [[hash rate rental attacks]]\n\n  - **Rainbow Tables and Pre-computation**\n    - [[Rainbow table]]: Pre-computed hash-to-plaintext lookup table\n    - Effective against unsalted password hashes\n    - Defeated by [[salt]]: random value concatenated before hashing\n    - Bitcoin addresses use public key (effectively random), resistant to rainbow tables\n    - [[PBKDF2]], [[Bcrypt]], [[Argon2]] provide slow hashing for passwords\n\n- ## Current Landscape and Industry Standards (2025)\n  id:: hash-function-landscape\n\n  - **Standardization and Compliance**\n    - [[NIST]] maintains Federal Information Processing Standards (FIPS) for hash functions\n    - FIPS 180-4 (SHA-2 family), FIPS 202 (SHA-3 family)\n    - [[ISO/IEC 10118]] series covers hash function standards\n    - [[NIST Post-Quantum Cryptography]] project addresses quantum threats\n    - European [[eIDAS]] regulation specifies approved hash algorithms\n\n  - **Performance Benchmarks**\n    - Modern processors: SHA-256 ~200-500 MB/s per core\n    - Hardware acceleration: Intel SHA extensions, ARM Cryptography Extensions\n    - GPU acceleration: 10-100x throughput for parallelizable operations\n    - ASIC implementation: >1000x efficiency for specific algorithms\n    - Blake2b: 2-10x faster than SHA-2 on general-purpose CPUs\n\n  - **Blockchain Ecosystem Adoption**\n    - **Bitcoin ecosystem**: SHA-256 dominant (Bitcoin, BCH, BSV)\n    - **Ethereum ecosystem**: Keccak-256 standard (Ethereum, Polygon, BSC)\n    - **Privacy coins**: Various (Blake2b for Zcash, RandomX for Monero)\n    - **Enterprise blockchains**: Often support multiple hash functions\n    - [[Layer 2]] solutions inherit hash functions from base layer\n\n- ## Future Directions and Research\n  id:: hash-function-future\n\n  - **Post-Quantum Hash Functions**\n    - Existing hash functions (SHA-2, SHA-3) considered quantum-resistant\n    - Research into hash-based signatures ([[SPHINCS+]], [[XMSS]])\n    - [[NIST PQC]] standardization includes hash-based signature schemes\n    - Quantum-resistant alternatives to ECDSA for blockchain applications\n\n  - **Emerging Hash Function Designs**\n    - [[Rescue]] and [[Poseidon]]: Optimized for [[zero-knowledge proofs]]\n    - [[MiMC]] and [[Griffin]]: Efficient in [[zkSNARK]] circuits\n    - Algebraic hash functions for [[ZKP]] applications\n    - Trade conventional security assumptions for ZKP efficiency\n\n  - **Hardware Acceleration Trends**\n    - Increased CPU support for cryptographic instructions\n    - GPU mining profitability declining, specialized hardware dominant\n    - [[Optical computing]] potential for hash computation\n    - [[Neuromorphic computing]] applications in pattern matching\n\n  - **Research Priorities**\n    - Formal verification of hash function security properties\n    - Lightweight hash functions for [[IoT]] and constrained devices\n    - Multi-party computation using hash-based primitives\n    - [[Homomorphic hashing]] for privacy-preserving applications\n    - Integration with [[zero-knowledge cryptography]]\n\n- ## Technical Implementation Examples\n  id:: hash-function-examples\n\n  - **Bitcoin Block Hash Calculation**\n    ```python\n    import hashlib\n\n    # Block header components (80 bytes total)\n    version = \"00000020\"\n    prev_block = \"000000000000000000041acd301c... (32 bytes)\"\n    merkle_root = \"4c6a6f6d8e7f3b2a1d9e... (32 bytes)\"\n    timestamp = \"5f6d7e8f\"\n    bits = \"17148edf\"\n    nonce = \"9c7a4b3d\"\n\n    block_header = version + prev_block + merkle_root + timestamp + bits + nonce\n\n    # Double SHA-256\n    hash1 = hashlib.sha256(bytes.fromhex(block_header)).digest()\n    hash2 = hashlib.sha256(hash1).hexdigest()\n\n    # Result: block hash (must be below target for valid block)\n    ```\n\n  - **Merkle Proof Verification**\n    ```python\n    def verify_merkle_proof(transaction_hash, merkle_proof, merkle_root):\n        \"\"\"Verify transaction inclusion using Merkle proof\"\"\"\n        current_hash = transaction_hash\n\n        for sibling_hash, direction in merkle_proof:\n            if direction == 'left':\n                combined = sibling_hash + current_hash\n            else:\n                combined = current_hash + sibling_hash\n\n            current_hash = hashlib.sha256(hashlib.sha256(combined).digest()).digest()\n\n        return current_hash == merkle_root\n    ```\n\n- ## Cross-References and Related Concepts\n  id:: hash-function-references\n\n  - **Core Cryptography**\n    - [[Public Key Cryptography]]\n    - [[Elliptic Curve Cryptography]]\n    - [[Symmetric Encryption]]\n    - [[Random Number Generation]]\n    - [[Zero-Knowledge Proofs]]\n\n  - **Blockchain Mechanisms**\n    - [[Consensus Algorithms]]\n    - [[Block Structure]]\n    - [[Transaction Validation]]\n    - [[Network Security]]\n    - [[Mining Economics]]\n\n  - **Data Structures**\n    - [[Merkle Trees]]\n    - [[Patricia Tries]]\n    - [[Bloom Filters]]\n    - [[Hash Maps]]\n    - [[Distributed Hash Tables]]\n\n- ## Standards and References\n  id:: hash-function-standards\n\n  - **Technical Standards**\n    - [[FIPS 180-4]]: Secure Hash Standard (SHA-2 family)\n    - [[FIPS 202]]: SHA-3 Standard (Keccak)\n    - [[ISO/IEC 10118]]: Hash function standards\n    - [[NIST SP 800-107]]: Recommendations for hash algorithms\n    - [[RFC 6234]]: SHA and HMAC-SHA algorithms\n\n  - **Academic References**\n    - Menezes, A., van Oorschot, P., & Vanstone, S. (1996). *Handbook of Applied Cryptography*. CRC Press.\n    - Bertoni, G., Daemen, J., Peeters, M., & Van Assche, G. (2011). *The Keccak SHA-3 Submission*.\n    - Nakamoto, S. (2008). *Bitcoin: A Peer-to-Peer Electronic Cash System*.\n    - National Institute of Standards and Technology (NIST). (2015). *SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions*. FIPS PUB 202.\n\n  - **Industry Resources**\n    - Bitcoin Core documentation: [[bitcoin.org/en/developer-reference]]\n    - Ethereum Yellow Paper: [[ethereum.github.io/yellowpaper]]\n    - NIST Cryptographic Standards: [[csrc.nist.gov]]\n    - UK National Cyber Security Centre (NCSC): Cryptographic guidance\n\n## Metadata\n\n- **Content Status**: Comprehensively enhanced 2025-11-15\n- **Authority Score**: 1.0 (foundational cryptographic concept)\n- **Bitcoin Focus**: SHA-256 mining, address generation, Merkle trees\n- **Total Wiki-Links**: 75+\n- **Line Count**: 380+\n- **Quality Target**: ≥0.89\n- **Last Comprehensive Update**: 2025-11-15\n- **Verification**: Technical accuracy verified against Bitcoin Core, NIST standards\n- **Related Ontology Terms**: [[BC-0027]], [[CryptographicPrimitive]], [[BlockchainEntity]]",
  "properties": {
    "id": "hash-function-standards",
    "collapsed": "true",
    "- domain-prefix": "BC",
    "- sequence-number": "0027",
    "- filename-history": "[\"BC-0027-hash-function.md\"]",
    "- public-access": "true",
    "- ontology": "true",
    "- term-id": "BC-0027",
    "- preferred-term": "Hash Function",
    "- source-domain": "blockchain",
    "- status": "complete",
    "- version": "1.0.0",
    "- last-updated": "2025-10-28",
    "- definition": "One-way data transformation within blockchain systems, providing essential functionality for distributed ledger technology operations and properties.",
    "- maturity": "mature",
    "- source": "[[ISO/IEC 23257:2021]], [[IEEE 2418.1]], [[NIST NISTIR]]",
    "- authority-score": "1.0",
    "- owl:class": "bc:HashFunction",
    "- owl:physicality": "VirtualEntity",
    "- owl:role": "Object",
    "- owl:inferred-class": "bc:VirtualObject",
    "- belongsToDomain": "[[CryptographicDomain]]",
    "- implementedInLayer": "[[SecurityLayer]]",
    "- is-subclass-of": "[[Blockchain Entity]], [[CryptographicPrimitive]]"
  },
  "backlinks": [
    "CryptographicDomain",
    "SHA-256",
    "Address"
  ],
  "wiki_links": [
    "Bcrypt",
    "public key cryptography",
    "NIST PQC",
    "Mining Economics",
    "Neuromorphic computing",
    "Merkle tree",
    "CID",
    "Decred",
    "Schnorr signatures",
    "salt",
    "SPV",
    "Schnorr",
    "length extension attacks",
    "extraNonce",
    "checkpoints",
    "P2SH",
    "transaction hashes",
    "Ethereum",
    "proof-of-work",
    "DAG",
    "NIST NISTIR",
    "IPLD",
    "digital signature security",
    "nonce",
    "Lightning Network",
    "Griffin",
    "Content addressing",
    "Random Number Generation",
    "RFC 6234",
    "Beam",
    "Layer 2",
    "Monero",
    "Bitcoin SV",
    "Zcash",
    "EVM",
    "multihash",
    "HMAC",
    "CryptographicPrimitive",
    "hash rate",
    "RandomX",
    "blocks",
    "cryptographic primitive",
    "ASIC",
    "BitTorrent",
    "transaction malleability",
    "FIPS 202",
    "Elliptic Curve Cryptography",
    "Nakamoto consensus",
    "Bitcoin SPV",
    "Second pre-image attack",
    "Collision attack",
    "NIST",
    "Block Structure",
    "Symmetric Encryption",
    "IPFS",
    "Merkle Trees",
    "CryptographicDomain",
    "bitcoin.org/en/developer-reference",
    "RIPEMD-160",
    "Git",
    "Pre-image attack",
    "eIDAS",
    "Blockchain Entity",
    "ethereum.github.io/yellowpaper",
    "NIST SP 800-107",
    "ProgPoW",
    "SPoRA",
    "FIPS 180-4",
    "Optical computing",
    "PBKDF2",
    "timestamp",
    "Shor's algorithm",
    "cryptographic hash function",
    "payment channels",
    "P2PKH",
    "Bitcoin Cash",
    "Mining pools",
    "Patricia Tries",
    "BlockchainEntity",
    "blockchain",
    "Merkle proof",
    "51% attack",
    "csrc.nist.gov",
    "Public Key Cryptography",
    "Ethereum addresses",
    "Nonce",
    "zero-knowledge proofs",
    "Arweave",
    "Transaction Validation",
    "Scrypt",
    "sponge construction",
    "EdDSA",
    "ECDSA",
    "NIST Post-Quantum Cryptography",
    "Permaweb",
    "Smart contracts",
    "Dogecoin",
    "Litecoin",
    "BIP37",
    "Difficulty adjustment",
    "Time-warp attack",
    "Bloom Filters",
    "zkSNARK",
    "finality gadgets",
    "SPHINCS+",
    "sighash types",
    "Zero-Knowledge Proofs",
    "SecurityLayer",
    "state roots",
    "Patricia trie",
    "Proof-of-Work",
    "Mining",
    "Distributed Hash Tables",
    "ISO/IEC 10118",
    "NSA",
    "Merkle DAG",
    "IEEE 2418.1",
    "Bitcoin",
    "Merkle Root",
    "Merkle-Damgård construction",
    "multisig",
    "birthday problem",
    "Digital signatures",
    "Hash rate",
    "Rescue",
    "Equihash",
    "Argon2",
    "Homomorphic hashing",
    "Grin",
    "Poseidon",
    "Ethash",
    "SegWit",
    "MiMC",
    "consensus mechanisms",
    "Bech32",
    "ZKP",
    "Merkle mountain range",
    "Hash Maps",
    "difficulty",
    "Network Security",
    "SHA-256",
    "zero-knowledge cryptography",
    "Miners",
    "Selfish mining",
    "IoT",
    "distributed ledger",
    "Apache Cassandra",
    "Grover's algorithm",
    "BC-0027",
    "Merkle root",
    "Sia",
    "XMSS",
    "data integrity",
    "digital signatures",
    "Rainbow table",
    "ISO/IEC 23257:2021",
    "Taproot",
    "Consensus Algorithms",
    "hash rate rental attacks",
    "Hashcash"
  ],
  "ontology": {
    "term_id": "BC-0027",
    "preferred_term": "Hash Function",
    "definition": "One-way data transformation within blockchain systems, providing essential functionality for distributed ledger technology operations and properties.",
    "source_domain": "blockchain",
    "maturity_level": null,
    "authority_score": 1.0
  }
}